# vim: syntax=python tabstop=4 expandtab
# coding: utf-8


"""
Using monovar installed via bioconda, available in your path as `monovar`.

The bioconda installation should also pull in samtools as a dependency.

Configuration should be provided in YAML format (e.g. config.yaml)
and loaded in the Snakefile.
"""

__author__ = "David Laehnemann (david.laehnemann@hhu.de)"
__license__ = "MIT"


def _get_ref(wildcards):
    return config["references"][wildcards.reference]


# get or set empty settings in config and config.settings
#config.setdefault("settings", {})
#config["settings"].setdefault("monovar", {})

# get or provide monovar defaults
#config["settings"]["monovar"].setdefault("MinQual", "20")

rule monovar_call_per_chr:
    input:
        ref = _get_ref,
        bams = lambda wildcards: expand("mapping/{reference}/samples/{sample}.bps.sorted.bam",
                    reference = wildcards.reference, sample = config["batches"][wildcards.batch]),
        bais = lambda wildcards: expand("mapping/{reference}/samples/{sample}.bps.sorted.bam.bai",
                    reference = wildcards.reference, sample = config["batches"][wildcards.batch]),
    output:
        vcf = tmp + "/" + config["project_name"] + "/variant_calling/{reference,[^/]+}/monovar/{batch,[^.]+}.{threshold,[^.]+}.c{consensus,[01]}.{chr,chr(?:\d{1,2}|[XYM])}.monovar.vcf"
    log:
        "log/variant_calling/{reference}/monovar/{batch}.{threshold}.c{consensus}.{chr}.monovar_call.log"
    threads: 2 
#    resources:
#        mem_gb = 2 # memory per thread
    conda: "envs/Benchmarking_ProSolo_py27.yaml"
    params: threshold = lambda wildcards: wildcards.threshold.replace('-','.')
    shell:
        'LIST="{input.bams}"; '
        'DIR=`pwd`; '
        'truncate -s 0 {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.list; '
        'for b in ${{LIST[@]}}; do echo $DIR/$b >> {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.list; done; '
        'samtools mpileup '
        '--region {wildcards.chr} '
        ' -Q 0 ' # do not exclude any reads due to base quality (MonoVar recommendations)
        ' -q 40 ' # exclude reads with a bad alignment quality (MonoVar recommendations)
        ' -d 10000 ' # if you have high coverage, use it (MonoVar recommendations)
        ' -f {input.ref} '
        ' -b {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.list | '
        'monovar ' # following recommendations, see repo: https://bitbucket.org/hamimzafar/monovar
        ' -p 0.002 ' # Offset for prior probability for false-positive error (Recommended value: 0.002)
        ' -a 0.2 ' # Offset for prior probability for allelic drop out (Default value: 0.2)
        ' -t {params.threshold} ' # Threshold to be used for variant calling (Recommended value: 0.05)
        ' -m 2 ' # Number of threads to use in multiprocessing (Default value: 1)
        ' -c {wildcards.consensus} ' # Flag indicating whether to use Consensus Filter (CF) or not (Possible values: 0, 1; Default Value: 1; if 1 then CF is used, otherwise not used) # comment David: apparently, setting this to '1' only sets the PASS flag to either PASS or '.' (<1% of sites for 5 PAG cells), whereas for '0', all sites get a '.'
        ' -f {input.ref} '
        ' -b {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.list '
        ' -o {output.vcf}.tmp; '
        'bcftools view -h {output.vcf}.tmp | grep ^## '
        ' > {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.hdr.tmp; '
        'bcftools mpileup --regions chr1:1-2 --fasta-ref {input.ref} {input.bams[0]} | grep "contig=<ID={wildcards.chr}," '
        ' >> {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.hdr.tmp; '
        'bcftools view -h {output.vcf}.tmp | grep ^#CHROM '
        ' >> {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.hdr.tmp; '
        'if [ {wildcards.consensus} == 1 ]; '
        'then '
        '  bcftools reheader '
        '   -h {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.hdr.tmp '
        '   {output.vcf}.tmp | '
        '  bcftools view '
        '   --apply-filters "PASS" '
        '   -o {output.vcf}; '
        'else '
        '  bcftools reheader '
        '   -h {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.hdr.tmp '
        '   -o {output.vcf} '
        '   {output.vcf}.tmp; '
        'fi; '
        'rm {output.vcf}.tmp '
        ' {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.list '
        ' {wildcards.batch}.{wildcards.threshold}.c{wildcards.consensus}.{wildcards.chr}.monovar.hdr.tmp; '

rule bcftools_concat_chrs_monovar:
    '''
    Concatenate per-chromosome VCF files produced by monovar; combine per
    genotyping unit of samples.
    '''
    input:
        vcfs = lambda wildcards: expand(
                tmp + "/" + config["project_name"] + "/variant_calling/{reference}/monovar/{unit}.{thr}.{cons}.{chrom}.monovar.vcf",
                reference = wildcards.reference,
                unit = wildcards.unit, thr = wildcards.thr,
                cons = wildcards.cons, chrom = chrlist)
    output: "variant_calling/{reference,[^/]+}/monovar/{unit,[^.]+}.{thr,[^.]+}.{cons,c[01]}.monovar.bcf"
    log: "log/variant_calling/{reference}/monovar/{unit}.{thr}.{cons}.bcftools_concat_chrs.monovar.log"
    threads: 1
    shell:
        "bcftools concat "
        "--output-type b " 
        "--output {output} "
        "{input.vcfs} "
        "2>&1 | tee {log} "

rule bcftools_split_monovar_by_cell:
    input:
        bcf = "variant_calling/{reference}/monovar/{unit}.{thr}.{cons}.monovar.bcf",
        idx = "variant_calling/{reference}/monovar/{unit}.{thr}.{cons}.monovar.bcf.csi"
    output: "variant_calling/{reference,[^/]+}/monovar/{sc,[^.]+}.{unit,[^.]+}.{thr,[^.]+}.{cons,c[01]}.monovar.bcf"
    log: "log/variant_calling/{reference}/monovar/monovar_split_cells/{sc}.{unit}.{thr}.{cons}.monovar.split.log"
    shell:
        "bcftools view --samples {wildcards.sc}.P --trim-alt-alleles -O b -o {output} {input.bcf}"

rule monovar_cell_to_tsv:
    input:
        "variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.bcf"
    output:
        "variant_calling/{reference,[^/]+}/monovar/{sc,[^.]+}.{batch,[^.]+}.{thr,[^.]+}.{cons,c[01]}.monovar.tsv"
    log:
        "log/variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar_to_tsv.log"
    shell:
        "bcftools view -h {input} | grep ^#CHROM | cut -f 1,2,4,5,10- | cut -c2- | "
        " sed -e 's/\.bps\.sorted\.bam//g' > {output}; "
        "bcftools norm --multiallelic -any -O u {input} | "
        "bcftools view -O u --types snps -e 'STRLEN(REF)>1||STRLEN(ALT)>1' | "
        "bcftools query -f '%CHROM\t%POS\t%REF\t%ALT[\t%GT]\n' >> {output} "

rule monovar_true_false_pos_neg_calculations:
    input:
        ground_truth = config["references"]["ground_truth"],
        calls = "variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.tsv"
    output:
        "variant_calling/{reference,[^/]+}/monovar/{sc,[^.]+}.{batch,[^.]+}.{thr,[^.]+}.{cons,c[01]}.monovar.positives_negatives.tsv"
    log:
        "log/variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.positives_negatives.log"
    resources:
        mem_gb = 15
    shell:
        "Rscript --vanilla " + include_prefix + "scripts/monovar.P-N_stats.alt-calling.R "
        " --gt {input.ground_truth} "
        " --calls {input.calls} "
        " --out {output} "
        " 2>&1 | tee {log} "

rule monovar_genotype_matching_calculations:
    input:
        ground_truth = config["references"]["ground_truth"],
        calls = "variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.tsv"
    output:
        "variant_calling/{reference,[^/]+}/monovar/{sc,[^.]+}.{batch,[^.]+}.{thr,[^.]+}.{cons,c[01]}.monovar.gt_matching.tsv"
    log:
        "log/variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.gt_matching.log"
    resources:
        mem_gb = 15
    shell:
        "Rscript --vanilla " + include_prefix + "scripts/monovar.genotype-calling.matches.R "
        " --gt {input.ground_truth} "
        " --calls {input.calls} "
        " --out {output} "
        " 2>&1 | tee {log} "


rule monovar_genotype_matching_calculations_minGQ_30:
    input:
        ground_truth = config["references"]["ground_truth_minGQ_30"],
        calls = "variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.tsv"
    output:
        "variant_calling/{reference,[^/]+}/monovar/{sc,[^.]+}.{batch,[^.]+}.{thr,[^.]+}.{cons,c[01]}.monovar.minGQ_30.gt_matching.tsv"
    log:
        "log/variant_calling/{reference}/monovar/{sc}.{batch}.{thr}.{cons}.monovar.min_GQ_30.gt_matching.log"
    resources:
        mem_gb = 15
    shell:
        "Rscript --vanilla " + include_prefix + "scripts/monovar.genotype-calling.matches.R "
        " --gt {input.ground_truth} "
        " --calls {input.calls} "
        " --out {output} "
        " 2>&1 | tee {log} "
 

